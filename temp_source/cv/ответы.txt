=====ООП=====
это подход создания программы, при котором вся программа рассматривается как набор взаимодействующих друг с другом объектов

Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, манипулирующий зтими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования

Наследование (inheritance) - это процесс, посредством которого один объект может приобретать свойства другого. Точнее, объект может наследовать основные свойства другого объекта и добавлять к ним черты, характерные только для него. 
Инкапсуляция обеспечивает разделение интерфейса и реализации
класса. Инкапсулируемый класс скрывает свою реализацию от
пользователей, которые могут использовать интерфейс, но не имеют
доступа к реализации класса.

====== Полиморфизм =======
По определению, полиморфизм - это состояние, при котором одна функция, в даном случае, сущность, может обрабатывать данные разных типов. 

======= АБСТРАКЦИЯ =======
Абстракция это способ представления объекта в программе. Т.е. использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи. 
Абстракция данных — программный подход, полагающийся на разделение интерфейса (interface) и реализации
(implementation). Интерфейс класса состоит из операций, которые
пользователь класса может выполнить с его объектом.

========КЛАСС======
Класс — представляет собой шаблон для создания объектов, обеспечивающий начальные значения состояний: инициализация полей-переменных и реализация поведения функций или методов.

========ОБЪЕКТ=======
Объект (экземпляр) – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом.

Объект ООП - это совокупность переменных состояния и связанных с ними методов(операций). Эти методы определяют как объект взаимодействует с окружающим миром.

Возможность управлять состояниями объекта посредством вызова методов в итоге и определять поведение объекта. Эту совокупность методов часто называют интерфейсом объекта.


Класс (class) - это группа данных и методов(функций) для работы с этими данными. Это шаблон. Объекты с одинаковыми свойствами, то есть с одинаковыми наборами переменных состояния и методов, образуют класс.

Объект (object)- это конкретная реализация, экземпляр класса. В программировании отношения объекта и класса можно сравнить с описанием переменной, где сама переменная(объект) является экземпляром какого-либо типа данных(класса). 


======Static METHOD======
Обычно статические методы используются для реализации функций, принадлежащих классу, но не к каким-то конкретным его объектам.




====================PHP=========================

Callback:
Функция обратного вызова (часто называемая просто "callback") — это функция, которая передается в качестве аргумента другой функции.




Вопрос 10 === Что такое интерфейс === :
Интерфейс определяет абстрактный дизайн, которому должен соответствовать применяющий его класс. Интерфейс определяет методы без реализации. А класс затем применяет интерфейс и реализует эти методы. Применение интерфейса гарантирует, что класс имеет определенный функционал, описываемый интерфейсом.

Интерфейс определяется с помощью ключевого слова interface, за которым следует имя интерфейса и блок кода интерфейса в фигурных скобках.
Внутри блока интерфейса в фигурных скобках определяются сигнатуры методов. Причем все эти методы могут быть только публичными, то есть с модификатором public.
Интерфейсы могут содержать лишь сигнатуры методов - наазвания функций и список параметров в скобках, после которого идет точка с запятой.

Для реализации классом интерфейса применяется ключевое слово implements, после которого указывается имя применяемого интерфейса.
Интерфейс - это контракт, который говорит, что класс обязательно реализует определенный функционал.




Вопрос 11 === Абстрактный класс и отличее от интерфейса === :
Абстрактный класс - используется для определения базового каркаса.
Одной из ключевых особенностей абстрактных классов является то, что мы не можем напрямую создать объекты абстрактного класса с помощью вызова его конструктора.
Абстрактные классы, как и обычные классы, могут определять переменные и константы, методы и конструкторы.

Но другой особенностью абстрактных классов является то, что они могут содержать абстрактные методы. Это методы, которые не имеют реализации.
Абстрактные методы могут размещаться только в абстрактных классах. Обычный неабстрактный класс не может иметь абстрактных методов.

Если неабстрактный класс наследуется от абстрактного класса, то он обязан реализовать все его абстрактные методы.


Разница между Абстракный классом и интерфейсом:

Интерфейс	                                                                Абстрактный класс
Поддерживаем множественное наследование	                                    Не поддерживаем множественное наследование
Не содержит data members	                                                Может содержать data members
Не содержит конструктор	                                                    Может содержать конструктор
Содержит только объявление методов (сигнатуры методов)	                    Может содержать как сигнатуры методов так и их реализации
Не может иметь модификаторов доступа - все методы по умолчанию публичные	Может иметь модификаторы доступа
Методы не могут быть статическими	                                        Только методы, содержащие реализацию, могут быть объявлены статическими

--1. Абстрактный класс действует как образец для классов, которые его наследуют. Дочерний класс, который наследует абстрактный класс, должен реализовывать методы, объявленые абстрактными в родительском классе. Абстрактный класс создается только для как элемент иерархии наследования. Это означает, что вы не можете создать объект абстрактного класса.

Интерфейс — это контракт. Он содержит только сигнатуры методов (без тела метода). Класс, который реализует интерфейс, должен реализовывать эти методы.

--2. Класс может расширять только один абстрактный класс, тогда как класс может реализовывать несколько интерфейсов.

--3. В абстрактном классе мы можем определить переменные экземпляра и конкретные (неабстрактные) методы.

    Но в интерфейсе все методы абстрактны. Мы не можем определить переменные экземпляра, но мы можем определить константы в интерфейсе.

--4. Абстрактный класс хорош, когда есть некоторые общие черты, которые должны быть общими для всех объектов.


Вопрос 12 === Может ли абстрактный класс содержать частный метод? === :
При наследовании от абстрактного класса, все методы, помеченные абстрактными в родительском классе, должны быть определены в дочернем классе.

При этом область видимости этих методов должна совпадать или быть менее строгой. Что значит менее строгой: например, если абстрактный метод объявлен как protected, то реализация этого метода должна быть protected или public, но не private.

Объявления методов также должны совпадать: количество обязательных параметром должно быть одинаковым. Однако класс-потомок может добавлять необязательные параметры, которые не были указаны при объявлении метода в родителе.



Вопрос 13 === Какие модификаторы доступа видимости в PHP? === :
Область видимости свойства, метода или константы (начиная c PHP 7.1.0) может быть определена путём использования следующих ключевых слов в объявлении: public, protected или private. Доступ к свойствам и методам класса, объявленным как public (общедоступный), разрешён отовсюду. Модификатор protected (защищённый) разрешает доступ самому классу, наследующим его классам и родительским классам. Модификатор private (закрытый) ограничивает область видимости так, что только класс, где объявлен сам элемент, имеет к нему доступ. 
Если же свойство определено с помощью var, то оно будет объявлено общедоступным свойством. 



Вопрос 14 === Что такое магические методы и какие есть? === :
В общем, магические методы PHP — это предопределенные методы, выполняемые при каком-либо конкретном событии, они автоматически вызываются, без вызова функции, когда удовлетворяется какое-либо из заданных условий
Магиеские методы - "магия" данных методов сводится к тому, что они могут перехватывать (отсюда их второе название - методы-перехватчики) сообщения, посланные неопределенным (по сути - несуществующим) методам и свойствам
Всегда начинаются с двойного подчеркивания.
__construct() - этот метод запускается автоматически при созданнии экземпляра класса
__destruct() - метод запускается автоматически при уничтожении обьекта
__call(), __callStatic() - перехватывают обращение к несуществующему методу в контексте объекта и в статическом контексте
__get(), __set() - выполняется при чтении/записи данных из недоступных свойств
__isset() - будет выполнен при использовании isset() или empty() на недоступных свойствах
__unset() - будет выполнен при вызове unset() на недоступном свойстве
__sleep() - вызывается, когда объект подвергается сериализации при помощи функции serialize()
__wakeup() - вызывается при восстановлении объекта при помощи функции unserialize()
__toString() - метод, с помощью которого можно обращаться к классу как к строке
__invoke() - вызывается при попытке использовать объект в качестве функции
__set_state() - метод, который вызывается для классов, экспортирующих значения свойств функцией var_export()
__clone() - вызывается при клонировании объекта
__debugInfo() - метод вызывается функцией var_dump(), когда необходимо вывести список свойств объекта



Вопрос 15 === Что такое генераторы === :
Генераторы представляют собой функции, обеспечивающие простой механизм для циклической обработки данных, без необходимости создавать массив данных в памяти.
Для возвращения значения из функции применяется оператор yield. Но в отличие от return оператор yield сохраняет состояние функции, позволяя ей продолжать работу с того места, когда остановилось ее выполнение



Вопрос 16 === Что делает оператор yield? ===:
В самом простом варианте оператор "yield" можно рассматривать как оператор "return", за исключением того, что вместо прекращения работы функции, "yield" только приостанавливает её выполнение и возвращает текущее значение, и при следующем вызове функции она возобновит выполнения с места, на котором прервалась.



Вопрос 17 === Что такое traits? Альтернативное решение? Приведите пример. === :
Трейты (англ. traits) - это механизм обеспечения повторного использования кода в языках с поддержкой единого наследования.
Они позволяют разработчику повторно использовать наборы методов и свойств в нескольких независимых классах. 
Трейт похож на класс, но создать экземпляр трейта невозможно.Он предназначен для группирования функционала, которыйпотом используется в разных классах.



Вопрос 18 === Опишите поведение при использовании traits с одинаковыми именами полей и / или методов. === :
Если два трейта добавляют метод с одним и тем же именем, это приводит к фатальной ошибке в случае, если конфликт явно не разрешён.
Для разрешения конфликтов именования между трейтами, используемыми в одном и том же классе, необходимо использовать оператор insteadof для того, чтобы точно выбрать один из конфликтующих методов.
Так как предыдущий оператор позволяет только исключать методы, оператор as может быть использован для включения одного из конфликтующих методов под другим именем. Обратите внимание, что оператор as не переименовывает метод и
не влияет на какой-либо другой метод.

Если трейт определяет свойство, то класс не может определить свойство с таким же именем, кроме случаев полного совпадения (те же начальное значение и модификатор видимости), иначе будет сгенерирована фатальная ошибка.



Вопрос 19 === Будут ли доступны частные методы trait в классе? === :
Внутри трейта мы можем использовать любой модификатор доступа (public, private, protected) для методов. Но, кроме этого, есть возможность в классе менять этот модификатор на другой. Для этого в теле use после слова as можно
указать новый модификатор.



Вопрос 20 === Можно ли компоновать traits в trait? === :
Аналогично тому, как классы могут использовать трейты, также могут и трейты использовать другие трейты. Используя один или более трейтов в определении другого трейта, он может частично или полностью состоять из членов,
описанных в этих трейтах.



Вопрос 21 ===  Расскажите об обработке ошибок и исключения (try catch, finaly и throw) === :
Модель исключений (exceptions) в PHP похожа с используемыми в других языках программирования. Исключение можно сгенерировать (выбросить) при помощи оператора throw, и можно перехватить (поймать) оператором catch. Код
генерирующий исключение, должен быть окружён блоком try, для того, чтобы можно было перехватить исключение. Каждый блок try должен иметь как минимум один соответствующий ему блок catch или finally.

В случае, если выброшено исключение, для которого нет блока catch в текущей функции, это исключение будет "всплывать" по стеку вызова, пока не будет найден подходящий блок catch. При этом, все встреченные блоки finally будут
исполнены. Если стек вызовов раскрутится до глобальной области видимости, не встретив подходящего блока catch, программа завершит работу с фатальной ошибкой, если только у вас не настроен глобальный обработчик исключений.

================catch 
Блок catch определяет то, как следует реагировать на выброшенное исключение. В блоке catch указывается один или более типов исключений или ошибок(Error), которые он будет обрабатывать. Также указывается и переменная, которой
будет присвоено пойманное исключение (начиная с PHP 8.0.0 задавать эту переменную не обязательно). Выброшенное исключение или ошибка будут обработаны первым подходящим блоком catch.
Можно использовать несколько блоков catch, перехватывающих различные классы исключений. Нормальное выполнение (когда не генерируются исключения в блоках try) будет продолжено за последним блоком catch. Исключения могут быть
сгенерированы (или вызваны ещё раз) оператором throw внутри блока catch. Если нет, то исполнение будет продолжено после отработки блока catch.
При генерации исключения код, следующий после описываемого выражения, не будет выполнен, а PHP попытается найти первый блок catch, перехватывающий исключение данного класса. Если исключение не будет перехвачено, PHP выдаст
фатальную ошибку: "Uncaught Exception ..." (Неперехваченное исключение), если не был определён обработчик ошибок при помощи функции set_exception_handler().

================finally
Блок finally также можно использовать после или вместо блока catch. Код в блоке finally всегда будет выполняться после кода в блоках try и catch, независимо от того, было ли выброшено исключение, перед тем как продолжится
нормальное выполнение кода.
Одно важное взаимодействие происходит между блоком finally и оператором return. Если оператор return встречается внутри блоков try или catch, блок finally всё равно будет выполнен. Кроме того, оператор return выполняется,
когда встречается, но результат будет возвращён после выполнения блока finally. Если блок finally также содержит оператор return, возвращается значение, указанное в блоке finally.



Вопрос 22 === Что такое type hinting, как работает, зачем нужен? === :
Тайп хинтинг (указание типов аргументов)
В PHP 7 появилась полноценная поддержка так называемых тайп хинтов (type hints). Мы можем указать, какой тип данных должен быть у передаваемого в функцию значения.
Если мы передадим в функцию значение, которое можно привести к требуемому типу (например, вместо строки передадим число), значение будет приведено к нужному типу. Если значение привести нельзя (например, массив нельзя
превратить в строку), произойдёт ошибка
Ещё одна фишка PHP 7 - возможность указать, какой тип данных должна возвращать функция. Если возможно, возвращаемое значение будет приведено к нужному типу, иначе мы получим ошибку



Вопрос 23 === Что такое namespace-ы и зачем они нужны? === :
В PHP пространства имён используются для решения двух проблем, с которыми сталкиваются авторы библиотек и приложений при создании повторно используемых элементов кода, таких как классы и функции:

Конфликт имён между вашим кодом и внутренними классами/функциями/константами PHP или сторонними.
Возможность создавать псевдонимы (или сокращения) для Ну_Очень_Длинных_Имён, чтобы облегчить первую проблему и улучшить читаемость исходного кода.
Пространства имён PHP предоставляют возможность группировать логически связанные классы, интерфейсы, функции и константы.
Пространство имён (англ. namespace) — некоторое множество, под которым подразумевается модель, абстрактное хранилище или окружение, созданное для логической группировки уникальных идентификаторов (то есть имён). Идентификатор,
определенный в пространстве имён, ассоциируется с этим пространством. Один и тот же идентификатор может быть независимо определён в нескольких пространствах.



Вопрос 24 === Сравнение значений переменных в РНР и подводные камни? Приведение типов. Что изменилось в PHP 8 в этом контексте? === :
В случае, если оба операнда являются строками, содержащими числа или один операнд является числом, а другой - строкой, содержащей числа, то сравнение выполняется численно. Эти правила также применяются к оператору switch.
Преобразование типа не происходит при сравнении === или !==, поскольку это включает сравнение типа, а также значения.

Приведение типа — это преобразование значения одного типа в значение другого типа.
Есть два вида приведения типов: явное неявное
Неявное приведение типа выполняется интерпретатором автоматически, без непосредственного участия программиста. Например, значение будет автоматически преобразовано, если оператор ожидает, числовые операнды
Чтобы выполнить явное приведение, нужно указать в круглых скобках имя требуемого типа непосредственно перед приводимым значением или переменной



Вопрос 25 === Как работает session в РНР, где хранится, как инициализируется? === :
Сессии представляют набор переменных, которые хранятся на сервере (либо часть на сервере, а часть - в cookie браузера) и которые относятся только к текущему пользователю. В какой-то степени сессии являются альтернативой кукам в плане сохранения данных о пользователе.

Для запуска сессии необходимо вызвать функцию session_start()
При запуске сессии с помощью функции session_start(), если пользователь первый раз заходит на сайт, PHP назначает ему уникальный идентификатор сессии. Этот идентификатор с помощью cookie, которые по умолчанию называются
"PHPSESSID", сохраняется в браузере пользователя. С помощью этого идентификатора пользователь ассоциируется с данными сессии. Если для пользователя уже установлена сессия, то данная функция продлевает текущую сессию вместо
установки новой.
Сохранение данных в сессии
Запустим сессию и сохраним в ней значения. После установки сессии в браузере мы сможем заметить установку специальной куки, которая по умолчанию называется "PHPSESSID"



Вопрос 26 === Суперглобальные массивы. Какие знаете? === :
В PHP версии 4 и выше введено понятие "суперглобальных" массивов. Эти массивы содержат всю информацию о состоянии сервера и среды выполнения скрипта. Массивы доступны в любом месте скрипта без дополнительных объявлений, т.е.
не надо использовать ключевое слово global.

Всего массивов девять. Имена всех массивов записываются заглавными буквами, а начинается имя всегда с "$_"
$_SERVER
$_GET и $_POST
$_COOKIES
$_REQUEST
$_SESSION



Вопрос 27 === Сравните include vs required, include_once vs required_once === :
Обе функции одинаковы, но они имеют одно различие. Разница в том, что функция include() выдает предупреждение, но скрипт продолжит выполнение, а функция require() выдает предупреждение и фатальную ошибку, т.е. скрипт не будет
продолжать выполнение. Эти две функции используются для помещения данных файла в другой файл PHP перед его выполнением сервером.
Отличия между require() и include() таковы, что require() возвращает FATAL ERROR, если файл не найден, include() же возвращает только WARNING.

Функция include_once() работает почти так же, как и include(), а отличия те же, что и между require() и require_once().



Вопрос 29 === Что такое замыкание в PHP? Пример === :
Замыкания в PHP представляют анонимную функцию, которая может использовать переменные из своего локального окружения. В отличие от обычных анонимных функций замыкания в PHP применяют выражение use.
Выражение use() получает внешние переменные, которые анонимная функция собирается использовать. И теперь при ее выполении браузер выведет значение переменной $number.
Подобным образом функция-замыкание может захватывать и большее количество внешних переменных, а также как и другие функции применять параметры



Вопрос 30 === В чем разница между замыканием в PHP и JavaScript? === :
JavaScript-замыкания являются полноценными объектами, тогда как в PHP они являются объектами с ограниченным доступом. Например, PHP Closures не может иметь свои собственные свойства:
PHP
$fn = function() {};
$fn->foo = 1;
// -> Catchable fatal error: Closure object cannot have properties

JS
var fn = function() {};
fn.foo = 1;
fn.foo; // 1


Одно из различий заключается в том, как оба справляются с сохранением контекста, в котором выполняется анонимная функция:

// JavaScript:
var a = 1;
var f = function() {
   console.log(a);
};
a = 2;
f();
// will echo 2;

// PHP
$a = 1;
$f = function() {
    echo $a;
};
$a = 2;
$f();
// will result in a "PHP Notice:  Undefined variable: a in Untitled.php on line 5"
Чтобы исправить это уведомление, вы должны будете использовать синтаксис use:

$a = 1;
$f = function() use ($a) {
    echo $a;
};
$a = 2;
$f();
// but this will echo 1 instead of 2 (like JavaScript)
Чтобы анонимная функция вела себя как аналог JavaScript, вам нужно использовать ссылки:

$a = 1;
$f = function() use (&$a) {
    echo $a;
};
$a = 2;
$f();
// will echo 2



Вопрос 31 === Что такое позднее связывание? Расскажите о поведении и применения static. === :
Если кратко, новая функциональность позднего статического связывания, позволяет объектам все также наследовать методы у родительских классов, но помимо этого дает возможность унаследованным методам иметь доступ к статическим константам, методам и свойствам класса потомка, а не только родительского класса
Внутренне, основное отличие (и, собственно, причина почему связывание назвали поздним) между этими двумя способами доступа, в том, что PHP определят значение для self::NAME во время «компиляции» (когда симовлы PHP преобразуются в машинный код, который будет обрабатываться движком Zend), а для static::NAME значение будет определено в момент запуска (в тот момент, когда машинный код будет выполнятся в движке Zend).

"Позднее связывание" отражает тот факт, что обращения через static:: не будут вычисляться по отношению к классу, в котором вызываемый метод определён, а будут вычисляться на основе информации в ходе исполнения.



Вопрос 34 === SOLID === :
Это набор правил и наилучших подходов, которым нужно следовать при создании структуры классов.
    Single Responsibility Principle («Принцип единой ответственности», SRP)
    Open-Closed Principle («Принцип открытости-закрытости», OCP)
    Liskov Substitution Principle («Принцип подстановки Барбары Лисков», LSP)
    Interface Segregation Principle («Принцип разделения интерфейса», ISP)
    Dependency Inversion Principle («Принцип инверсии зависимостей», DIP)
Принцип единственной ответственности
Принцип единственной ответственности гласит, что класс должен делать какое-то одно действие и, соответственно, для его изменения должна быть только одна причина.
Можно сказать и более «техническим» языком: влиять на спецификацию класса должно только какое-то одно потенциальное изменение в спецификации программы (логика базы данных, логика журналирования и т. п.).

Принцип открытости-закрытости
Принцип открытости-закрытости требует, чтобы классы были открыты для расширения, но закрыты для модификации.
Под модификацией подразумевается изменение кода существующих классов, а под расширением — добавление нового функционала.
В общем, этот принцип имеет в виду следующее: у нас должна быть возможность добавлять новый функционал, не трогая существующий код класса. Это связано с тем, что когда мы модифицируем существующий код, мы рискуем создать потенциальные баги. Поэтому следует по возможности избегать прикасаться к протестированному и надежному (в целом) коду в продакшене.
Но как же добавить новый функционал, не прикасаясь к классу? Обычно это делается при помощи интерфейсов и абстрактных классов

Принцип подстановки Барбары Лисков
Принцип подстановки Барбары Лисков гласит, что подклассы должны заменять свои базовые классы.
Это означает следующее. Если у нас есть класс B, являющийся подклассом класса A, у нас должна быть возможность передать объект класса B любому методу, который ожидает объект класса A, причем этот метод не должен выдать в таком случае какой-то странный output.
Это ожидаемое поведение, потому что когда мы используем наследование, мы предполагаем, что дочерний класс наследует все, что есть у суперкласса. Дочерний класс расширяет поведение, но никогда не сужает его.

Принцип разделения интерфейса
Разделение подразумевает, что вещи нужно хранить отдельно друг от друга, а принцип разделения интерфейса касается (сюрприз!) разделения интерфейсов.
Этот принцип гласит: много клиентоориентированных интерфейсов лучше, чем один интерфейс общего назначения. Клиенты не должны принуждаться к реализации функций, которые им не нужны.


Принцип инверсии зависимостей
Принцип инверсии зависимостей гласит, что наши классы должны зависеть от интерфейсов или абстрактных классов, а не от конкретных классов и функций
— Код должен зависеть от абстракций, а не от конкретных классов;
— Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций;
— Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.


вопрос 51 === разница между одинарными и двойными кавычками === :

Какой вид кавычек использовать для оформления строк - апострофы или классические двойные кавычки?

Давайте разберем разницу между двойными и одинарными кавычками в PHP, и на примерах выясним, когда какие нужно использовать.

Переменные и экранирующие последовательности для специальных символов, встречающихся в строках, заключенных в одинарные кавычки - не обрабатываются. Строки, обрамленные апострофами, обрабатываются интерпретатором PHP гораздо быстрее, чем аналогичные строки, окруженные двойными кавычками.

Причина здесь проста: строки в двойных кавычках интерпретатор PHP дополнительно проверяет на наличие переменных и если такие находятся, то вместо имени переменной в строку вставляется ее значение. А вот строка, заключенная в апострофы, воспринимается интерпретатором как обычный текст и никаких преобразований в этих строках PHP не проводит. Думаю, понятно, что обработка строк в одинарных кавычках в любом случае будет происходить быстрее.









====================================================LARAVEL=============================================



======Сервисный слой========
Сервисный слой (Service layer) — это шаблон проектирования, который инкапсулирует бизнес логику вашего приложения и определяет границу и набор допустимых операций с точки зрения взаимодействующих с ним клиентов.


Вопрос 37 === Что такое MVC === :
Шаблон MVC описывает простой способ построения структуры приложения, целью которого является отделение бизнес-логики от пользовательского интерфейса. Согласно этому принципу, данные хранятся отдельно от методов, взаимодействующих с этими данными.
Типичную последовательность работы MVC-приложения можно описать следующим образом:

    При заходе пользователя на веб-ресурс, скрипт инициализации создает экземпляр приложения и запускает его на выполнение.
    При этом отображается вид, скажем главной страницы сайта.
    Приложение получает запрос от пользователя и определяет запрошенные контроллер и действие. В случае главной страницы, выполняется действие по умолчанию (index).
    Приложение создает экземпляр контроллера и запускает метод действия,
    в котором, к примеру, содержаться вызовы модели, считывающие информацию из базы данных.
    После этого, действие формирует представление с данными, полученными из модели и выводит результат пользователю.


Модель — содержит бизнес-логику приложения и включает методы выборки (это могут быть методы ORM), обработки (например, правила валидации) и предоставления конкретных данных, что зачастую делает ее очень толстой, что вполне нормально.
Модель не должна напрямую взаимодействовать с пользователем. Все переменные, относящиеся к запросу пользователя должны обрабатываться в контроллере.
Модель не должна генерировать HTML или другой код отображения, который может изменяться в зависимости от нужд пользователя. Такой код должен обрабатываться в видах.
Одна и та же модель, например: модель аутентификации пользователей может использоваться как в пользовательской, так и в административной части приложения. В таком случае можно вынести общий код в отдельный класс и наследоваться от него, определяя в наследниках специфичные для подприложений методы.


Вид — используется для задания внешнего отображения данных, полученных из контроллера и модели.
Виды cодержат HTML-разметку и небольшие вставки PHP-кода для обхода, форматирования и отображения данных.
Не должны напрямую обращаться к базе данных. Этим должны заниматься модели.
Не должны работать с данными, полученными из запроса пользователя. Эту задачу должен выполнять контроллер.
Может напрямую обращаться к свойствам и методам контроллера или моделей, для получения готовых к выводу данных.
Виды обычно разделяют на общий шаблон, содержащий разметку, общую для всех страниц (например, шапку и подвал) и части шаблона, которые используют для отображения данных выводимых из модели или отображения форм ввода данных.


Контроллер — связующее звено, соединяющее модели, виды и другие компоненты в рабочее приложение. Контроллер отвечает за обработку запросов пользователя. Контроллер не должен содержать SQL-запросов. Их лучше держать в моделях. Контроллер не должен содержать HTML и другой разметки. Её стоит выносить в виды.
В хорошо спроектированном MVC-приложении контроллеры обычно очень тонкие и содержат только несколько десятков строк кода. Чего, не скажешь о Stupid Fat Controllers (SFC) в CMS Joomla. Логика контроллера довольно типична и большая ее часть выносится в базовые классы.
Модели, наоборот, очень толстые и содержат большую часть кода, связанную с обработкой данных, т.к. структура данных и бизнес-логика, содержащаяся в них, обычно довольно специфична для конкретного приложения



=======Класс Request в Laravel======
Класс Illuminate\Http\Request Laravel предлагает объектно-ориентированный способ взаимодействия с текущим HTTP-запросом, обрабатываемым вашим приложением, а также извлечение входных данных, файлов Cookies и файлов, отправленных вместе с запросом.



=======Для чего нужны Resource=======
Класс ресурсов представляет собой единую модель, которую необходимо преобразовать в структуру JSON. Каждый класс ресурсов определяет метод toArray, который возвращает массив атрибутов, которые должны быть преобразованы в JSON, когда ресурс возвращается в качестве ответа из метода маршрута или контроллера.
Например, бывает необходимо отображать определенные атрибуты только для некоторого сегмента пользователей, а не для всех, или бывает необходимо всегда отображать определенные отношения в JSON-представление ваших моделей. Классы ресурсов Eloquent позволяют легко и выразительно преобразовывать модели и коллекции моделей в JSON. Ресурсы Eloquent обеспечивают более детальный и надежный контроль над сериализацией в JSON ваших моделей и их отношений.


=======Sercice provider========
Сервис провайдеры — это По сути это функции-посредники, необходимые, чаще всего, чтобы закидывать некоторые сервисы в некое «быстрое хранилище» Сервис-контейнер.
А что такое сервис? А вот это как раз тот самый функциональный блок, который нам нужен. Отправка смс, вывод статистики по чему-либо и т.д.
Ваше приложение, а также сервисы самого фреймворка загружаются через сервис-провайдеры.



=======ROUTE======
Все роуты Laravel определены в файлах роутов, которые расположены в директории routes. Эти файлы автоматически загружаются фреймворком. В файле routes/web.php определены роуты для вашего web-интерфейса. Эти роуты входят в группу посредников web, которые обеспечивают такие возможности, как состояние сессии и CSRF-защита. Роуты из файла routes/api.php не сохраняют состояние приложения и входят в группу посредников api.



=====CSRF======
CSRF – это аббревиатура для Подделка межсайтовых запросов. Маркер CSRF - это уникальное значение, которое генерируется на стороне сервера приложения и отправляется клиенту.
Токен CSRF помогает защитить веб-приложения от атак, заставляющих пользователя выполнять нежелательное действие (общеизвестный как CSRF-атаки).

-----Controllers-------
Вместо того, чтобы определять всю логику обработки запросов в виде замыканий в файлах роутов, вы можете организовать её с помощью классов контроллеров. Контроллеры могут группировать связанную с обработкой HTTP-запросов логику в отдельный класс. Контроллеры хранятся в директории app/Http/Controllers.



========Миграции=========
Миграции - позволяют создавать струтуру таблица в БД, а так же изменять ее, добавлять или удалять какие то столбци из нее. Для создания новой миграции используйте Artisan-команду make:migration. Класс миграций содержит два метода: up и down. Метод up используется для добавления новых таблиц, столбцов а метод down для отмены миграции. 


===== Отношение ОДИН К ОДНОМУ ======
Связь вида «один к одному» является очень простой. К примеру, модель User может иметь один Phone. Чтобы определить такое отношение, мы помещаем метод phone в модель User. Метод phone должен вызвать метод hasOne и вернуть его результат. Eloquent определяет внешний ключ отношения по имени модели. В данном случае предполагается, что модель Phone автоматически будет иметь внешний ключ user_id.

    public function phone()
    {
        return $this->hasOne('App\Phone');
    }



======== Один ко многим ============

Отношение "один ко многим" используется для определения отношений, где одна модель владеет некоторым количеством других моделей.
public function comments()
    {
        return $this->hasMany('App\Comment');
    }


======= Отношение многие ко многим =========
Связь многие-ко-многим – это связь, при которой множественным записям из одной таблицы (A) могут соответствовать множественные записи из другой (B). Примером такой связи может служить школа, где учителя обучают учащихся. В большинстве школ каждый учитель обучает многих учащихся, а каждый учащийся может обучаться несколькими учителями.
работа с отношением «многие-ко-многим» требует наличия промежуточной таблицы. 





